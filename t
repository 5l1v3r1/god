[1mdiff --git a/god.go b/god.go[m
[1mindex 63845a7..3552a5a 100644[m
[1m--- a/god.go[m
[1m+++ b/god.go[m
[36m@@ -1,34 +1,34 @@[m
 package main[m
 [m
 import ([m
[31m-	"bytes"[m
[31m-	"flag"[m
[31m-	"fmt"[m
[31m-	"github.com/carmark/pseudo-terminal-go/terminal"[m
[31m-	"github.com/common-nighthawk/go-figure"[m
[31m-	"github.com/fatih/color"[m
[31m-	"github.com/manifoldco/promptui"[m
[31m-	"github.com/olekukonko/tablewriter"[m
 	"io"[m
[32m+[m	[32m"fmt"[m
 	"os"[m
[32m+[m	[32m"flag"[m
[32m+[m	[32m"bytes"[m
 	"os/exec"[m
 	"strings"[m
[32m+[m	[32m"github.com/fatih/color"[m
[32m+[m	[32m"github.com/manifoldco/promptui"[m
[32m+[m	[32m"github.com/olekukonko/tablewriter"[m
[32m+[m	[32m"github.com/common-nighthawk/go-figure"[m
[32m+[m	[32m"github.com/carmark/pseudo-terminal-go/terminal"[m
 )[m
 [m
 var version = "1.0"[m
[31m-var outb, errb bytes.Buffer                 // Buffer for command output[m
[32m+[m[32mvar outb, errb bytes.Buffer // Buffer for command output[m
 var cmdSlice, gitCmdSlice, allCmds []string // Slice for the shortened git commands[m
[31m-var gitShortcuts [][]string                 // 2-d slice for the git shortcuts[m
[32m+[m[32mvar gitShortcuts[][] string // 2-d slice for the git shortcuts[m
 var whiteColor (*color.Color) = color.New(color.FgWhite, color.Bold)[m
 var restartTerm bool = false // Handling the stdout issues.[m
[31m-var termChar = "#"           // Character for non-git terminal commands.[m
[32m+[m[32mvar termChar = "#" // Character for non-git terminal commands.[m
 var promptStr = "[god ~]$ "[m
 [m
 // Executes the terminal command and returns output.[m
 // stdout parameter determines the output stream.[m
[31m-func execCmd(input string, stdout bool) string {[m
[31m-	// Remove the newline character.[m
[31m-	input = strings.TrimSuffix(input, "\n")[m
[32m+[m[32mfunc execCmd(input string, stdout bool) (string) {[m
[32m+[m[32m    // Remove the newline character.[m
[32m+[m[32m    input = strings.TrimSuffix(input, "\n")[m
 	// Prepare the command to execute.[m
 	// sh used for handling the command parameters.[m
 	// Otherwise, exec library takes the parameters[m
[36m@@ -36,25 +36,25 @@[m [mfunc execCmd(input string, stdout bool) string {[m
 	// want due to the complexity of git commands.[m
 	cmd := exec.Command("sh", "-c", input)[m
 	// Set the correct output device.[m
[31m-	if stdout {[m
[31m-		cmd.Stderr = os.Stderr[m
[32m+[m	[32mif stdout{[m
[32m+[m[41m    [m	[32mcmd.Stderr = os.Stderr[m
 		cmd.Stdout = os.Stdout[m
[31m-	} else {[m
[32m+[m	[32m}else{[m
 		cmd.Stdout = &outb[m
 		cmd.Stderr = &errb[m
 	}[m
[31m-	// Execute the command and return output[m
[32m+[m	[32m// Execute the command and return output[m[41m [m
 	// depending on the stdout parameter.[m
 	cmd.Run()[m
[31m-	if !stdout {[m
[32m+[m	[32mif (!stdout) {[m
 		return outb.String()[m
[31m-	}[m
[32m+[m	[32m}[m[41m [m
 	return ""[m
 }[m
 [m
 // Search the given query in slice.[m
 // Returns true if the element exists.[m
[31m-func searchInSlice(slice []string, query string) bool {[m
[32m+[m[32mfunc searchInSlice(slice []string, query string) (bool) {[m
 	set := make(map[string]bool)[m
 	for _, v := range slice {[m
 		set[v] = true[m
[36m@@ -64,7 +64,7 @@[m [mfunc searchInSlice(slice []string, query string) bool {[m
 [m
 // Returns a slice with given dimension parameter.[m
 // Used for getting keys or values from a 2-d slice.[m
[31m-func getShortcutSlice(slice [][]string, d int) []string {[m
[32m+[m[32mfunc getShortcutSlice(slice [][]string, d int) ([]string){[m
 	var shortcuts []string[m
 	for _, shortcut := range slice {[m
 		shortcuts = append(shortcuts, shortcut[d])[m
[36m@@ -73,7 +73,7 @@[m [mfunc getShortcutSlice(slice [][]string, d int) []string {[m
 }[m
 [m
 // Prepare (shorten) the git commands.[m
[31m-func prepareCmds() []string {[m
[32m+[m[32mfunc prepareCmds() ([]string){[m
 	// Show status if repository exists in directory.[m
 	execCmd("git status", true)[m
 	// Trimming the string using sed.[m
[36m@@ -84,34 +84,34 @@[m [mfunc prepareCmds() []string {[m
 	// Parsing the git commands.[m
 	// grep '^  *[a-z]' -> Select the lines starting with indent.[m
 	// tr -d '*' -> Remove the '*' character.[m
[31m-	parseGitCmd :=[m
[32m+[m	[32mparseGitCmd :=[m[41m [m
 		"git help | grep '^  *[a-z]' | " + removeSpaces +[m
[31m-			"git branch | tr -d '*' | " + removeSpaces +[m
[31m-			"git remote"[m
[32m+[m		[32m"git branch | tr -d '*' | " + removeSpaces +[m
[32m+[m		[32m"git remote"[m
 	cmdStr := execCmd(parseGitCmd, false)[m
 	gitCmdSlice = strings.Split(cmdStr, "\n")[m
 	for i, cmd := range gitCmdSlice {[m
[31m-		if len(cmd) > 0 {[m
[32m+[m		[32mif (len(cmd) > 0){[m
 			// Use the first character of git command[m
 			// for the new command if not exists in the[m
 			// commands slice. (cmdSlice)[m
[31m-			// If first character is in the list, compose[m
[32m+[m			[32m// If first character is in the list, compose[m[41m [m
 			// a two character abbreviation for it and[m
 			// add it to slice.[m
 			firstChar := string([]rune(cmd)[0])[m
[31m-			if !searchInSlice(cmdSlice, firstChar) {[m
[32m+[m			[32mif (!searchInSlice(cmdSlice, firstChar)){[m
 				cmdSlice = append(cmdSlice, firstChar)[m
[31m-			} else {[m
[31m-				cmdSlice = append(cmdSlice, firstChar+[m
[31m-					string([]rune(cmd)[len(cmd)/2]))[m
[32m+[m			[32m}else{[m
[32m+[m				[32mcmdSlice = append(cmdSlice, firstChar +[m[41m [m
[32m+[m					[32mstring([]rune(cmd)[len(cmd)/2]))[m[41m [m
 			}[m
[31m-		} else {[m
[32m+[m		[32m}else{[m
 			// Remove empty character[m
 			gitCmdSlice = append(gitCmdSlice[:i], gitCmdSlice[i+1:]...)[m
 		}[m
 	}[m
 	// Add git shortcuts.[m
[31m-	gitShortcuts = append(gitShortcuts,[m
[32m+[m	[32mgitShortcuts = append(gitShortcuts,[m[41m [m
 		[]string{"add -A", "aa"},[m
 		[]string{"commit -m", "cmt"},[m
 		[]string{"remote -v", "rmt"},[m
[36m@@ -126,29 +126,29 @@[m [mfunc prepareCmds() []string {[m
 [m
 // Create a git command from the given string.[m
 // Returns changed/new command.[m
[31m-func buildCmd(line string) string {[m
[32m+[m[32mfunc buildCmd(line string) (string) {[m
 	line = " " + line + " "[m
 	// Run command without git if it starts[m
 	// with '#' character.[m
[31m-	if strings.Contains(string([]rune(line)[:2]), termChar) {[m
[31m-		return strings.Replace(line, " "+termChar, " ", 1)[m
[32m+[m	[32mif (strings.Contains(string([]rune(line)[:2]), termChar)) {[m
[32m+[m		[32mreturn strings.Replace(line, " " + termChar, " ", 1)[m
 	}[m
 	// Support the commands starting with git.[m
 	line = strings.Replace(line, " git ", " ", -1)[m
 	// Replace the shortened command with its original.[m
 	for index, cmd := range append(cmdSlice, getShortcutSlice(gitShortcuts, 1)...) {[m
 		cmd = " " + cmd + " "[m
[31m-		if strings.Contains(line, cmd) {[m
[31m-			line = strings.Replace(line, cmd, " "+allCmds[index]+" ", -1)[m
[31m-		} else if strings.Contains(line, strings.ToUpper(cmd)) {[m
[31m-			line = strings.Replace(line, strings.ToUpper(cmd), " "+allCmds[index]+" ", -1)[m
[32m+[m		[32mif (strings.Contains(line, cmd)) {[m
[32m+[m			[32mline = strings.Replace(line, cmd, " " + allCmds[index] + " ", -1)[m
[32m+[m		[32m}else if (strings.Contains(line, strings.ToUpper(cmd))) {[m
[32m+[m			[32mline = strings.Replace(line, strings.ToUpper(cmd), " " + allCmds[index] + " ", -1)[m
 		}[m
 	}[m
 	return "git" + line[m
 }[m
 [m
 // Start the interactive shell.[m
[31m-func startTerm(persistent bool) {[m
[32m+[m[32mfunc startTerm(persistent bool){[m
 	term, err := terminal.NewWithStdInOut()[m
 	if err != nil {[m
 		panic(err)[m
[36m@@ -156,18 +156,18 @@[m [mfunc startTerm(persistent bool) {[m
 	defer term.ReleaseFromStdInOut()[m
 	whiteColor.Println("Type '?' for help or 'git' for list of commands.")[m
 	term.SetPrompt(promptStr)[m
[31m-cmdLoop:[m
[32m+[m	[32mcmdLoop:[m
 	for {[m
 		// Read the keyboard input.[m
 		line, err := term.ReadLine()[m
 		// Exit on Ctrl-D and Ctrl-C (if -p not provided).[m
[31m-		if (err == io.EOF) || (line == "^C" && !persistent) {[m
[32m+[m		[32mif ((err == io.EOF) || (line == "^C" && !persistent)) {[m
 			fmt.Println()[m
 			return[m
 		}[m
 		// Built-in commands.[m
[31m-		switch line {[m
[31m-		case "", " ":[m
[32m+[m		[32mswitch line{[m
[32m+[m		[32mcase "", " ":[m[41m [m
 			break[m
 		case "clear":[m
 			execCmd("clear", true)[m
[36m@@ -182,13 +182,13 @@[m [mcmdLoop:[m
 		case "sc":[m
 			showShortcuts()[m
 		case "alias":[m
[31m-			prompAlias()[m
[32m+[m			[32mpromptAlias()[m
 		default:[m
 			// Build the git command.[m
 			gitCmd := buildCmd(line)[m
 			// Release the std in/out for preventing the[m
 			// git username & password input issues.[m
[31m-			if strings.Contains(gitCmd, "push") {[m
[32m+[m			[32mif (strings.Contains(gitCmd, "push")){[m
 				restartTerm = true[m
 				term.ReleaseFromStdInOut()[m
 			}[m
[36m@@ -198,7 +198,7 @@[m [mcmdLoop:[m
 			}[m
 			// Restart the terminal for flushing the stdout.[m
 			// It is necessary for input required situations.[m
[31m-			if restartTerm {[m
[32m+[m			[32mif (restartTerm) {[m
 				term, err = terminal.NewWithStdInOut()[m
 				defer term.ReleaseFromStdInOut()[m
 				term.SetPrompt(promptStr)[m
[36m@@ -209,12 +209,12 @@[m [mcmdLoop:[m
 }[m
 [m
 // Takes 'table' parameter and returns colored.[m
[31m-func setTableColors(table *tablewriter.Table) *tablewriter.Table {[m
[32m+[m[32mfunc setTableColors(table (*tablewriter.Table)) (*tablewriter.Table) {[m
 	whiteTable := tablewriter.Colors{[m
[31m-		tablewriter.Bold,[m
[32m+[m		[32mtablewriter.Bold,[m[41m [m
 		tablewriter.FgHiWhiteColor}[m
 	blackTable := tablewriter.Colors{[m
[31m-		tablewriter.Bold,[m
[32m+[m		[32mtablewriter.Bold,[m[41m [m
 		tablewriter.FgHiBlackColor}[m
 	table.SetHeaderColor(whiteTable, whiteTable)[m
 	table.SetColumnColor(whiteTable, blackTable)[m
[36m@@ -222,15 +222,15 @@[m [mfunc setTableColors(table *tablewriter.Table) *tablewriter.Table {[m
 }[m
 [m
 // Display help message.[m
[31m-func showHelp() {[m
[32m+[m[32mfunc showHelp(){[m
 	cliCmds := map[string]string{[m
[31m-		"git":     "List available git commands",[m
[31m-		"sc":      "List git shortcuts",[m
[31m-		"alias":   "Print shell or git aliases",[m
[31m-		"help":    "Show this help message",[m
[32m+[m		[32m"git": "List available git commands",[m
[32m+[m		[32m"sc": "List git shortcuts",[m
[32m+[m		[32m"alias": "Print shell or git aliases",[m
[32m+[m		[32m"help": "Show this help message",[m
 		"version": "Show version information",[m
[31m-		"clear":   "Clear the terminal",[m
[31m-		"exit":    "Exit shell"}[m
[32m+[m		[32m"clear": "Clear the terminal",[m[41m [m
[32m+[m		[32m"exit": "Exit shell"}[m
 	table := tablewriter.NewWriter(os.Stdout)[m
 	table.SetHeader([]string{"Command", "Description"})[m
 	table = setTableColors(table)[m
[36m@@ -241,7 +241,7 @@[m [mfunc showHelp() {[m
 }[m
 [m
 // Show git commands in table.[m
[31m-func showCommands() {[m
[32m+[m[32mfunc showCommands(){[m
 	table := tablewriter.NewWriter(os.Stdout)[m
 	table.SetHeader([]string{"Command", "git"})[m
 	table = setTableColors(table)[m
[36m@@ -252,7 +252,7 @@[m [mfunc showCommands() {[m
 }[m
 [m
 // Show commonly used git commands shortcuts.[m
[31m-func showShortcuts() {[m
[32m+[m[32mfunc showShortcuts(){[m
 	table := tablewriter.NewWriter(os.Stdout)[m
 	table.SetHeader([]string{"Shortcut", "Command"})[m
 	table = setTableColors(table)[m
[36m@@ -263,14 +263,14 @@[m [mfunc showShortcuts() {[m
 }[m
 [m
 // Save shortened commands as shell alias or Git alias.[m
[31m-func prompAlias() {[m
[32m+[m[32mfunc promptAlias(){[m
 	aliasOpts := []string{[m
 		"shell",[m
 		"git",[m
 	}[m
[31m-	formats := map[string]string{[m
[32m+[m	[32mformats := map[string] string {[m
 		"shell": "alias %s='git %s'",[m
[31m-		"git":   "%s = %s",[m
[32m+[m		[32m"git": "%s = %s",[m
 	}[m
 	aliasPrompt := promptui.Select{[m
 		Label: "Create alias for",[m
[36m@@ -280,7 +280,7 @@[m [mfunc prompAlias() {[m
 	if err != nil {[m
 		fmt.Printf("Selection failed: %v\n", err)[m
 	}[m
[31m-	if len(selection) > 0 {[m
[32m+[m	[32mif (len(selection) > 0){[m
 		whiteColor.Println("Alias list for " + selection + ":")[m
 		for index, cmd := range append(cmdSlice, getShortcutSlice(gitShortcuts, 1)...) {[m
 			alias := fmt.Sprintf(formats[selection], cmd, allCmds[index])[m
[36m@@ -290,7 +290,7 @@[m [mfunc prompAlias() {[m
 }[m
 [m
 // Show project information including version.[m
[31m-func showVersion() {[m
[32m+[m[32mfunc showVersion(){[m
 	fmt.Println()[m
 	asciiFigure := figure.NewFigure("god", "cosmic", true)[m
 	asciiFigure.Print()[m
[36m@@ -306,9 +306,9 @@[m [mfunc main() {[m
 	versionFlag := flag.Bool("v", false, "Show version information")[m
 	persistentFlag := flag.Bool("p", false, "Don't exit on ^C")[m
 	flag.Parse()[m
[31m-	if *versionFlag {[m
[31m-		showVersion()[m
[31m-	} else {[m
[32m+[m	[32mif(*versionFlag){[m
[32m+[m		[32mshowVersion()[m[41m	[m
[32m+[m	[32m}else{[m
 		prepareCmds()[m
 		startTerm(*persistentFlag)[m
 	}[m
